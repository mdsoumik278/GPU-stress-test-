<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM OVERLOAD // 10X STRESS</title>
    <style>
        :root { --p: #ff003c; --s: #00f0ff; --bg: #050505; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Consolas', monospace; color: var(--s); }
        canvas { display: block; }

        /* HUD STYLING */
        #hud {
            position: absolute; top: 0; left: 0; width: 380px; height: 100vh;
            background: rgba(5, 5, 5, 0.9);
            border-right: 2px solid var(--p);
            padding: 20px; box-sizing: border-box;
            backdrop-filter: blur(5px);
            transform: translateX(0); transition: transform 0.3s;
            overflow-y: auto; z-index: 100;
        }
        #hud.collapsed { transform: translateX(-360px); }
        
        .header { 
            border: 1px solid var(--p); color: var(--p); padding: 10px; text-align: center;
            font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px var(--p);
            animation: pulse 1s infinite alternate; margin-bottom: 20px;
        }
        @keyframes pulse { from { box-shadow: 0 0 5px var(--p); } to { box-shadow: 0 0 20px var(--p); } }

        .panel { border-left: 2px solid var(--s); padding-left: 10px; margin-bottom: 20px; background: linear-gradient(90deg, rgba(0,240,255,0.05) 0%, transparent 100%); }
        h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #fff; }

        /* CONTROLS */
        .control-group { margin-bottom: 10px; }
        label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 5px; color: #aaa; }
        input[type=range] { width: 100%; height: 5px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 15px; height: 15px; background: var(--p); cursor: pointer; border-radius: 50%; box-shadow: 0 0 10px var(--p); }
        
        .val { color: var(--s); font-weight: bold; }
        .danger { color: var(--p); }

        /* GRAPHS & VIZ */
        #perf-graph { width: 100%; height: 60px; background: #111; border: 1px solid #333; margin-top: 5px; }
        
        .core-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 2px; margin-top: 5px; }
        .core { height: 20px; background: #220; transition: 0.1s; }
        .core.active { background: var(--p); box-shadow: 0 0 10px var(--p); }

        button {
            width: 100%; padding: 15px; background: var(--p); color: #fff; border: none;
            font-weight: bold; font-size: 16px; cursor: pointer; text-transform: uppercase;
            letter-spacing: 2px; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        button:hover { background: #ff4d73; box-shadow: 0 0 20px var(--p); }

        #toggle-hud {
            position: absolute; top: 10px; left: 390px; z-index: 101;
            background: var(--s); color: #000; border: none; padding: 5px 10px; cursor: pointer;
            font-weight: bold;
        }

        /* WARNING OVERLAY */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1), rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px);
            z-index: 50; mix-blend-mode: overlay;
        }
    </style>
</head>
<body>

    <div id="overlay"></div>
    <button id="toggle-hud" onclick="document.getElementById('hud').classList.toggle('collapsed')">/// TOGGLE HUD</button>

    <div id="hud">
        <div class="header">
            WARNING: HIGH LOAD<br>
            <span style="font-size:10px; color:#fff;">SYSTEM INTEGRITY AT RISK</span>
        </div>

        <!-- GPU CONTROLS -->
        <div class="panel">
            <h3>GPU: FRACTAL RENDERER</h3>
            
            <div class="control-group">
                <label>INTERNAL RESOLUTION <span id="res-val" class="val">1.0x</span></label>
                <input type="range" id="res-slider" min="0.5" max="3.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>RAY ITERATIONS (HEAT) <span id="iter-val" class="val">100</span></label>
                <input type="range" id="iter-slider" min="50" max="500" step="10" value="100">
            </div>

            <div class="control-group">
                <label>SOFT SHADOWS (EXPENSIVE) <span id="shadow-val" class="val">OFF</span></label>
                <input type="range" id="shadow-slider" min="0" max="1" step="1" value="0">
            </div>

            <label>FPS MONITOR</label>
            <canvas id="perf-graph" width="300" height="60"></canvas>
            <div style="font-size:10px; margin-top:2px;">CURRENT: <span id="fps-txt" class="danger">60</span> FPS</div>
        </div>

        <!-- CPU CONTROLS -->
        <div class="panel">
            <h3>CPU: CRYPTO WORKERS</h3>
            
            <div class="control-group">
                <label>THREAD COUNT <span id="cpu-val" class="val">0</span></label>
                <input type="range" id="cpu-slider" min="0" max="32" step="1" value="0">
            </div>

            <div class="core-grid" id="cpu-viz"></div>
            <div style="font-size:10px; margin-top:5px; color:#aaa;">ALGO: SHA-256 SIMULATION (INTENSE INTEGER MATH)</div>
        </div>

        <button id="kill-btn">EMERGENCY STOP</button>
        <div style="text-align:center; margin-top:10px; font-size:9px; color:#555;">USE AT YOUR OWN RISK.</div>
    </div>

    <!-- THREE.JS IMPORT -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. SETUP & UTILS
        // ==========================================
        const canvas = document.createElement('canvas');
        canvas.style.width = "100vw"; canvas.style.height = "100vh";
        document.body.appendChild(canvas);

        const renderer = new THREE.WebGLRenderer({ canvas, powerPreference: "high-performance", antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Performance Monitor
        const perfCtx = document.getElementById('perf-graph').getContext('2d');
        let fpsHistory = new Array(300).fill(60);
        
        function updateGraph(fps) {
            fpsHistory.push(fps);
            fpsHistory.shift();
            
            perfCtx.fillStyle = '#000';
            perfCtx.fillRect(0,0,300,60);
            
            perfCtx.beginPath();
            perfCtx.moveTo(0, 60 - fpsHistory[0]);
            for(let i=1; i<300; i++) {
                let h = Math.max(0, 60 - fpsHistory[i]);
                perfCtx.lineTo(i, h);
            }
            perfCtx.strokeStyle = fps < 20 ? '#ff003c' : '#00f0ff';
            perfCtx.lineWidth = 2;
            perfCtx.stroke();
        }

        // ==========================================
        // 2. THE 10X SHADER (MANDELBOX FRACTAL)
        // ==========================================
        // This shader is extremely expensive due to Distance Estimation (DE)
        // and loop counts.
        
        const fragmentShader = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform int iIter;      // Iterations
            uniform int iShadows;   // 0 or 1

            // --- FRACTAL MATH (MANDELBOX) ---
            float DE(vec3 pos) {
                float scale = 2.8;
                vec3 p = pos;
                float d = 1.0;
                
                for(int i=0; i<8; i++) { // Recursive folding
                    // Box Fold
                    p = clamp(p, -1.0, 1.0) * 2.0 - p;
                    // Sphere Fold
                    float r2 = dot(p,p);
                    if(r2 < 0.5) { p *= 4.0; d *= 4.0; }
                    else if(r2 < 1.0) { p /= r2; d /= r2; }
                    
                    p = p * scale + pos;
                    d = d * abs(scale) + 1.0;
                }
                return length(p) / abs(d);
            }

            // --- LIGHTING ---
            float softShadow(vec3 ro, vec3 rd, float k) {
                if(iShadows == 0) return 1.0;
                float res = 1.0;
                float t = 0.01;
                for(int i=0; i<32; i++) {
                    float h = DE(ro + rd * t);
                    if(h < 0.001) return 0.0;
                    res = min(res, k * h / t);
                    t += h;
                    if(t > 10.0) break;
                }
                return res;
            }

            vec3 calcNormal(vec3 p) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(
                    DE(p+e.xyy)-DE(p-e.xyy),
                    DE(p+e.yxy)-DE(p-e.yxy),
                    DE(p+e.yyx)-DE(p-e.yyx)
                ));
            }

            // --- RAYMARCHING ---
            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                
                // Camera Animation
                float t = iTime * 0.2;
                vec3 ro = vec3(2.5 * sin(t), 2.5 * cos(t*0.7), 2.5 * sin(t*0.5)); // Orbiting
                vec3 lookAt = vec3(0.0);
                vec3 f = normalize(lookAt - ro);
                vec3 r = normalize(cross(vec3(0,1,0), f));
                vec3 u = cross(f, r);
                vec3 rd = normalize(f + uv.x * r + uv.y * u);

                vec3 col = vec3(0.0);
                float d = 0.0;
                float t_march = 0.0;
                int steps = 0;

                // MAIN LOOP
                for(int i=0; i<1000; i++) {
                    if(i >= iIter) break; // User limit
                    
                    vec3 p = ro + rd * t_march;
                    d = DE(p);
                    
                    if(d < 0.001) { // Hit
                        vec3 n = calcNormal(p);
                        vec3 lightDir = normalize(vec3(0.8, 1.0, -0.5));
                        
                        float dif = clamp(dot(n, lightDir), 0.0, 1.0);
                        float sha = softShadow(p + n * 0.01, lightDir, 16.0);
                        float amb = 0.5 + 0.5 * n.y; // Ambient
                        
                        // Coloring based on iteration/position
                        vec3 baseCol = 0.5 + 0.5 * cos(vec3(0,2,4) + length(p)*2.0);
                        
                        col = baseCol * dif * sha;
                        col += vec3(0.1, 0.2, 0.3) * amb;
                        
                        // Fog
                        col = mix(col, vec3(0.0), 1.0 - exp(-0.1 * t_march));
                        break;
                    }
                    
                    t_march += d;
                    if(t_march > 10.0) break; // Far clip
                    steps++;
                }

                // Glow/Bloom based on steps (Heatmap)
                col += vec3(1.0, 0.2, 0.0) * (float(steps) / float(iIter)) * 0.5;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
            iIter: { value: 100 },
            iShadows: { value: 0 }
        };
        const material = new THREE.ShaderMaterial({ fragmentShader, vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`, uniforms });
        scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

        // ==========================================
        // 3. UI LOGIC (GPU)
        // ==========================================
        const resSlider = document.getElementById('res-slider');
        const iterSlider = document.getElementById('iter-slider');
        const shadowSlider = document.getElementById('shadow-slider');
        const fpsTxt = document.getElementById('fps-txt');

        resSlider.addEventListener('change', () => { // Change on release
            const s = parseFloat(resSlider.value);
            document.getElementById('res-val').innerText = s.toFixed(1) + "x";
            const w = window.innerWidth * s;
            const h = window.innerHeight * s;
            renderer.setSize(window.innerWidth, window.innerHeight, false); // Keep CSS size, change buffer
            renderer.setPixelRatio(s);
            uniforms.iResolution.value.set(w, h);
        });

        iterSlider.addEventListener('input', (e) => {
            uniforms.iIter.value = parseInt(e.target.value);
            document.getElementById('iter-val').innerText = e.target.value;
        });

        shadowSlider.addEventListener('input', (e) => {
            uniforms.iShadows.value = parseInt(e.target.value);
            document.getElementById('shadow-val').innerText = e.target.value == 1 ? "ON" : "OFF";
            document.getElementById('shadow-val').classList.toggle('danger', e.target.value == 1);
        });

        // ==========================================
        // 4. CPU LOGIC (WEB WORKERS)
        // ==========================================
        const cpuSlider = document.getElementById('cpu-slider');
        const cpuViz = document.getElementById('cpu-viz');
        const maxCores = 32;
        let workers = [];

        // Build visualizer grid
        for(let i=0; i<maxCores; i++) {
            const d = document.createElement('div');
            d.className = 'core';
            d.id = `core-${i}`;
            cpuViz.appendChild(d);
        }

        // WORKER CODE: SHA-256 Simulation (Heavy Integer Math)
        const workerCode = `
            self.onmessage = function(e) {
                if(e.data === 'burn') {
                    // Pre-allocate memory to stress RAM slightly
                    const mem = new Uint32Array(1024); 
                    let nonce = 0;
                    
                    while(true) {
                        // Simulated Hashing (Bitwise mixing)
                        // This prevents simple optimizations by JS engine
                        let h = 0x6a09e667;
                        for(let i=0; i<1000; i++) {
                            nonce++;
                            // Chaotic bit mixing
                            let a = (h >> 2) ^ (h << 5) ^ nonce;
                            h = (a * 1664525 + 1013904223) | 0;
                            mem[i % 1024] = h; // Memory write
                        }
                    }
                }
            };
        `;
        const blob = new Blob([workerCode], {type: 'text/javascript'});
        const workerUrl = URL.createObjectURL(blob);

        cpuSlider.addEventListener('input', (e) => {
            const target = parseInt(e.target.value);
            document.getElementById('cpu-val').innerText = target;
            if(target > 12) document.getElementById('cpu-val').classList.add('danger');
            else document.getElementById('cpu-val').classList.remove('danger');

            // Add workers
            while(workers.length < target) {
                const w = new Worker(workerUrl);
                w.postMessage('burn');
                workers.push(w);
                document.getElementById(`core-${workers.length-1}`).classList.add('active');
            }
            // Remove workers
            while(workers.length > target) {
                const w = workers.pop();
                w.terminate();
                document.getElementById(`core-${workers.length}`).classList.remove('active');
            }
        });

        // ==========================================
        // 5. RENDER LOOP
        // ==========================================
        let lastTime = 0;
        let frameCount = 0;
        let timer = 0;

        function animate(time) {
            uniforms.iTime.value = time * 0.001;
            renderer.render(scene, camera);
            
            // FPS Counter
            frameCount++;
            if(time - timer >= 1000) {
                fpsTxt.innerText = frameCount;
                updateGraph(frameCount);
                frameCount = 0;
                timer = time;
            }
        }
        renderer.setAnimationLoop(animate);

        // ==========================================
        // 6. EMERGENCY STOP
        // ==========================================
        document.getElementById('kill-btn').addEventListener('click', () => {
            renderer.setAnimationLoop(null);
            workers.forEach(w => w.terminate());
            workers = [];
            document.body.innerHTML = `
                <div style="display:flex; justify-content:center; align-items:center; height:100vh; background:#000; color:#0f0; font-family:monospace; flex-direction:column;">
                    <h1 style="font-size:40px;">SYSTEM HALTED</h1>
                    <p>ALL PROCESSES TERMINATED SUCCESSFULLY.</p>
                    <button onclick="location.reload()" style="width:200px; margin-top:20px; background:#333;">REBOOT</button>
                </div>
            `;
        });

        // Initial Resize
        window.addEventListener('resize', () => {
            const s = parseFloat(resSlider.value);
            const w = window.innerWidth * s;
            const h = window.innerHeight * s;
            renderer.setSize(window.innerWidth, window.innerHeight, false);
            renderer.setPixelRatio(s);
            uniforms.iResolution.value.set(w, h);
        });

    </script>
</body>
</html>